<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¶ Sticker Tool v3.5 - é€æ˜èƒŒæ™¯çµ‚æ¥µç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <style>
        :root { --line-green: #00c300; --bg: #f4f6f8; --purple: #6c5ce7; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); margin: 0; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); padding: 30px; }
        
        header { text-align: center; border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 20px; }
        .version-tag { background: var(--line-green); color: white; padding: 5px 10px; border-radius: 20px; font-size: 0.9rem; vertical-align: middle; }

        .menu-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 30px; }
        .menu-btn { background: white; border: 2px solid #ddd; border-radius: 15px; padding: 20px; text-align: center; cursor: pointer; transition: 0.2s; }
        .menu-btn:hover, .menu-btn.active { border-color: var(--line-green); background: #f0fff4; transform: translateY(-5px); }
        .menu-btn .icon { font-size: 2.5rem; display: block; margin-bottom: 10px; }

        .section { display: none; animation: fadeIn 0.3s; }
        .section.show { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* å‹•æ…‹æ’­æ”¾å€ (èƒŒæ™¯ç‚ºæ£‹ç›¤æ ¼ï¼Œé¡¯ç¤ºé€æ˜æ•ˆæœ) */
        #anime-player { background: #222; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: center; border: 4px solid var(--line-green); }
        #anime-screen { 
            width: 240px; height: 240px; object-fit: contain; background: #333; border: 2px solid #555; 
            /* æ£‹ç›¤æ ¼èƒŒæ™¯ï¼Œç”¨ä¾†è¥¯æ‰˜é€æ˜åœ–ç‰‡ */
            background-image: linear-gradient(45deg, #444 25%, transparent 25%), linear-gradient(-45deg, #444 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #444 75%), linear-gradient(-45deg, transparent 75%, #444 75%);
            background-size: 20px 20px;
        }

        .upload-box { border: 3px dashed #ccc; padding: 30px; text-align: center; border-radius: 15px; cursor: pointer; position: relative; margin-bottom: 20px; }
        .upload-box:hover { border-color: var(--line-green); background: #fafafa; }
        .upload-box input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        
        .btn-action { background: var(--line-green); color: white; border: none; padding: 15px 30px; border-radius: 50px; font-size: 1.1rem; font-weight: bold; cursor: pointer; width: 100%; transition: 0.2s; }
        .btn-action:hover { filter: brightness(1.1); }
        .btn-apng { background: var(--purple); margin-top: 15px; } 

        #preview-wall { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; }
        .preview-thumb { aspect-ratio: 1; background: #eee; border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        .preview-thumb img { max-width: 90%; max-height: 90%; }
        
        canvas { display: none; }
        .options-bar { background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 20px; font-weight: bold; color: #555; }
        input[type=checkbox] { transform: scale(1.2); margin-right: 8px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>ğŸ¶ Sticker Tool <span class="version-tag">v3.5 é€æ˜ç‰ˆ</span></h1>
        <p>ç¢ºèªæ¨™é¡Œæ˜¯ç¶ è‰²çš„ v3.5ï¼Œæ”¯æ´è‡ªå‹•å»èƒŒåˆæˆ APNGï¼</p>
    </header>

    <div class="menu-grid">
        <div class="menu-btn" onclick="showSection('sec-crop')"><span class="icon">âœ‚ï¸</span><h3>1. åœ–é›†åˆ‡å‰²</h3></div>
        <div class="menu-btn" onclick="showSection('sec-anime')"><span class="icon">ğŸï¸</span><h3>2. å‹•æ…‹é è¦½ & åˆæˆ</h3></div>
        <div class="menu-btn" onclick="showSection('sec-static')"><span class="icon">âœ¨</span><h3>3. éœæ…‹æ‰“åŒ…</h3></div>
    </div>

    <div id="sec-crop" class="section show">
        <div class="upload-box">
            <div style="font-size: 3rem;">ğŸ“‚</div>
            <p>ä¸Šå‚³åœ–é›† (ä¾‹å¦‚ 4x5 è—è‰²å°æ€ªç¸)</p>
            <input type="file" accept="image/*" onchange="loadCropImage(this)">
        </div>
        <div class="options-bar">
            ç¶²æ ¼è¨­å®šï¼šæ¬„ <input type="number" id="cols" value="4" style="width: 40px;"> åˆ— <input type="number" id="rows" value="5" style="width: 40px;">
            <button onclick="drawGrid()" style="padding: 5px 15px; cursor:pointer;">æ›´æ–°ç¶²æ ¼</button>
        </div>
        <canvas id="crop-canvas" style="display:block; max-width:100%; margin:0 auto; background:#333;"></canvas>
        <button class="btn-action" style="margin-top: 20px;" onclick="executeCrop()">ğŸš€ åˆ‡å‰²ä¸¦å‚³é€åˆ°å‹•æ…‹é è¦½</button>
    </div>

    <div id="sec-anime" class="section">
        <div class="options-bar" style="background: #e8f5e9; color: var(--line-green);">
            <label style="cursor:pointer; display:flex; align-items:center;"><input type="checkbox" id="auto-process" checked onchange="reProcessFrames()"> âœ¨ è‡ªå‹•å»èƒŒ + ç™½è‰²æé‚Š</label>
        </div>
        <div id="anime-player">
            <img id="anime-screen" src="">
            <div style="color: white; margin-top: 15px;">
                æ’­æ”¾é€Ÿåº¦: <input type="range" id="fps" min="1" max="20" value="10" oninput="updateFPS()"> <span id="fps-val">10</span> FPS
            </div>
            <p id="frame-count" style="color: #aaa; font-size: 0.8rem;">å°šæœªè¼‰å…¥åœ–ç‰‡</p>
        </div>
        
        <button class="btn-action btn-apng" onclick="generateAPNG()">ğŸ“¦ åˆæˆä¸¦ä¸‹è¼‰é€æ˜ APNG</button>
        
        <div class="upload-box" style="margin-top: 20px; padding: 20px;">
            <p>æˆ–æ‰‹å‹•ä¸Šå‚³å¤šå¼µåºåˆ—åœ–</p>
            <input type="file" multiple accept="image/*" onchange="loadAnimeFiles(this.files)">
        </div>
    </div>

    <div id="sec-static" class="section">
        <div id="preview-wall"></div>
        <p id="static-status" style="text-align: center; color: #666; margin: 20px 0;">ç­‰å¾…åœ–ç‰‡...</p>
        <button class="btn-action" onclick="downloadZip()">ğŸ“¦ ä¸‹è¼‰åºåˆ—åœ– ZIP</button>
    </div>
</div>

<script>
    let originalFrames = []; // å­˜åŸå§‹åœ–
    let processedFrames = []; // å­˜å»èƒŒå¾Œçš„åœ– (ç”¨æ–¼æ’­æ”¾å’Œä¸‹è¼‰)
    let cropImg = null;
    let timer = null;
    let frameIdx = 0;

    function showSection(id) {
        document.querySelectorAll('.section').forEach(el => el.classList.remove('show'));
        document.querySelectorAll('.menu-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(id).classList.add('show');
        if(id !== 'sec-anime') clearInterval(timer);
    }

    // --- æ ¸å¿ƒï¼šAI å»èƒŒèˆ‡æé‚Š ---
    async function aiProcess(dataUrl) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                // 1. å»ºç«‹ç•«å¸ƒä¸¦åŠ ä¸Šé‚Šè·
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const padding = 10; // LINE å»ºè­°é‚Šè·
                canvas.width = img.width + padding * 2;
                canvas.height = img.height + padding * 2;
                ctx.drawImage(img, padding, padding);

                // 2. è‡ªå‹•å»èƒŒ (é‡å°æ¥è¿‘ç™½è‰²çš„èƒŒæ™¯)
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = imgData.data;
                for (let i = 0; i < d.length; i += 4) {
                    const r = d[i], g = d[i + 1], b = d[i + 2];
                    // å¦‚æœåƒç´ å¾ˆäº® (æ¥è¿‘ç™½è‰²)ï¼Œå°‡å…¶é€æ˜åº¦ (Alpha) è¨­ç‚º 0
                    if (r > 230 && g > 230 && b > 230) {
                        d[i + 3] = 0;
                    }
                }
                ctx.putImageData(imgData, 0, 0);

                // 3. åŠ ä¸Šç™½è‰²æé‚Š (åˆ©ç”¨é™°å½±æ¿¾é¡)
                const sCanvas = document.createElement('canvas');
                sCanvas.width = canvas.width; sCanvas.height = canvas.height;
                const sCtx = sCanvas.getContext('2d');
                sCtx.shadowColor = 'white';
                sCtx.shadowBlur = 4; // æé‚Šåšåº¦
                // åœ¨å››å€‹æ–¹å‘ç¹ªè£½ä»¥å¢å¼·æé‚Š
                sCtx.drawImage(canvas, -2, 0); sCtx.drawImage(canvas, 2, 0);
                sCtx.drawImage(canvas, 0, -2); sCtx.drawImage(canvas, 0, 2);
                // å°‡åŸåœ–è“‹åœ¨ä¸Šé¢ï¼Œç¢ºä¿å…§éƒ¨ä¸è¢«å¡«æ»¿
                sCtx.drawImage(canvas, 0, 0);

                resolve(sCanvas.toDataURL("image/png"));
            };
            img.src = dataUrl;
        });
    }

    // --- é‡æ–°è™•ç†æµç¨‹ (ç•¶é–‹é—œåˆ‡æ›æ™‚) ---
    async function reProcessFrames() {
        if(originalFrames.length === 0) return;
        document.getElementById('frame-count').innerText = "æ­£åœ¨è™•ç†å»èƒŒèˆ‡æé‚Š...";
        clearInterval(timer);
        
        const useAI = document.getElementById('auto-process').checked;
        processedFrames = [];

        for(let src of originalFrames) {
            if(useAI) {
                const processed = await aiProcess(src);
                processedFrames.push(processed);
            } else {
                processedFrames.push(src);
            }
        }
        startPlay();
        updateStaticPreview();
    }

    // --- åˆ‡å‰²é‚è¼¯ ---
    function loadCropImage(input) {
        if(!input.files[0]) return;
        const r = new FileReader();
        r.onload = (e) => {
            cropImg = new Image();
            cropImg.onload = () => {
                const cv = document.getElementById('crop-canvas');
                cv.width = cropImg.width; cv.height = cropImg.height;
                drawGrid();
            };
            cropImg.src = e.target.result;
        };
        reader.readAsDataURL(input.files[0]);
    }

    function drawGrid() {
        if(!cropImg) return;
        const cv = document.getElementById('crop-canvas'); const ctx = cv.getContext('2d');
        ctx.drawImage(cropImg, 0, 0);
        const c = document.getElementById('cols').value, r = document.getElementById('rows').value;
        const w = cv.width/c, h = cv.height/r;
        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 3; ctx.setLineDash([6, 4]);
        for(let i=1; i<c; i++){ctx.beginPath();ctx.moveTo(i*w,0);ctx.lineTo(i*w,cv.height);ctx.stroke();}
        for(let j=1; j<r; j++){ctx.beginPath();ctx.moveTo(0,j*h);ctx.lineTo(cv.width,j*h);ctx.stroke();}
    }

    async function executeCrop() {
        if(!cropImg) return alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
        const c = document.getElementById('cols').value, r = document.getElementById('rows').value;
        const w = cropImg.width/c, h = cropImg.height/r;
        
        originalFrames = [];
        const tempCv = document.createElement('canvas'); const tempCtx = tempCv.getContext('2d');
        tempCv.width = w; tempCv.height = h;

        for(let i=0; i<r; i++) {
            for(let j=0; j<c; j++) {
                tempCtx.clearRect(0,0,w,h);
                tempCtx.drawImage(cropImg, j*w, i*h, w, h, 0, 0, w, h);
                originalFrames.push(tempCv.toDataURL("image/png"));
            }
        }
        showSection('sec-anime');
        reProcessFrames(); // åˆ‡å‰²å®Œç«‹åˆ»é€²è¡Œè™•ç†
    }

    // --- å‹•æ…‹æ’­æ”¾ ---
    function loadAnimeFiles(files) {
        originalFrames = [];
        let loaded = 0;
        Array.from(files).forEach((f, i) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                originalFrames[i] = e.target.result; loaded++;
                if(loaded === files.length) reProcessFrames();
            };
            reader.readAsDataURL(f);
        });
    }

    function startPlay() {
        clearInterval(timer);
        if(processedFrames.length === 0) return;
        document.getElementById('frame-count').innerText = `ç›®å‰è¼‰å…¥ï¼š${processedFrames.length} å¼µå½±æ ¼ (å·²è™•ç†)`;
        const fps = document.getElementById('fps').value;
        timer = setInterval(() => {
            document.getElementById('anime-screen').src = processedFrames[frameIdx];
            frameIdx = (frameIdx + 1) % processedFrames.length;
        }, 1000 / fps);
    }

    function updateFPS() {
        document.getElementById('fps-val').innerText = document.getElementById('fps').value;
        startPlay();
    }

    // --- APNG åˆæˆ ---
    async function generateAPNG() {
        if(processedFrames.length === 0) return alert("è«‹å…ˆè¼‰å…¥åœ–ç‰‡ï¼");
        const fps = document.getElementById('fps').value;
        const delay = 1000 / fps;
        
        const buffs = [];
        // ä½¿ç”¨è™•ç†å¾Œçš„ç¬¬ä¸€å¼µåœ–ä¾†æ±ºå®šå°ºå¯¸
        const img = new Image();
        await new Promise(r => { img.onload = r; img.src = processedFrames[0]; });
        const w = img.width, h = img.height;
        
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');

        for(let i=0; i<processedFrames.length; i++) {
            await new Promise(resolve => {
                const frameImg = new Image();
                frameImg.onload = () => {
                    ctx.clearRect(0, 0, w, h);
                    ctx.drawImage(frameImg, 0, 0, w, h);
                    buffs.push(ctx.getImageData(0, 0, w, h).data.buffer);
                    resolve();
                };
                frameImg.src = processedFrames[i];
            });
        }
        const apngBlob = UPNG.encode(buffs, w, h, 0, new Array(processedFrames.length).fill(delay));
        const link = document.createElement('a');
        link.download = "animation.png";
        link.href = URL.createObjectURL(new Blob([apngBlob], {type: "image/png"}));
        link.click();
    }

    function updateStaticPreview() {
        const wall = document.getElementById('preview-wall'); wall.innerHTML = '';
        processedFrames.forEach(src => {
            const div = document.createElement('div'); div.className = 'preview-thumb';
            div.innerHTML = `<img src="${src}">`; wall.appendChild(div);
        });
        document.getElementById('static-status').innerText = `æº–å‚™æ‰“åŒ… ${processedFrames.length} å¼µå·²è™•ç†åœ–ç‰‡`;
    }

    function downloadZip() {
        if(processedFrames.length === 0) return alert('æ²’æœ‰åœ–ç‰‡');
        const zip = new JSZip();
        processedFrames.forEach((src, i) => zip.file(`${i+1}.png`, src.split(',')[1], {base64: true}));
        zip.generateAsync({type:"blob"}).then(b => { const a=document.createElement('a'); a.download="frames.zip"; a.href=URL.createObjectURL(b); a.click(); });
    }
</script>
</body>
</html>
